(* lexical *)

digit = '0' .. '9';

number = {digit}+;

letter = 'a' .. 'z';

sub_digit = '‚ÇÄ' .. '‚Çâ';

var = letter [sub_digit];

long_id = 'œÄ' | 'œÉ' | 'œÑ' | '‚àè' | 'ùîπ' | '‚Ñï' | '‚Ñ§' | 'ùí´' | 'gcd';

base_id = letter | long_id;

id = var | long_id;

sym = digit |
    '+' | '-' | '<' | '>' | '|' | '~' | '^' |
    '¬∑' | '‚â§' | '‚â•' | '‚âÆ' | '‚âØ' | '‚àí' | '‚äÜ';

id_or_sym = id | sym;

word = letter {letter};

adjective = word;

name_char = name_char;  (* ' ' or any printable char except '[', ']', ':' *)

name = {name_char}+;

sub_letter = '‚Çê' .. '‚Çì';

sub_sym = '‚Çä' | '‚Çã';

super_digit = '‚Å∞' .. '‚Åπ';

(* types *)

type_op = '‚®Ø' | '‚Üí';

typ = id | typ type_op typ | 'Set' '(' typ ')' | '(' typ ')';

of_type = (':' typ | '‚àà' id);

id_type = id of_type;

id_opt_type = id [of_type];

decl_ids = id_or_sym {',' id_or_sym};

decl_ids_type = decl_ids of_type;

decl_ids_types = decl_ids_type {'and' decl_ids_type};

(* terms *)

parens_exprs = '(' expr {',' expr} ')';

sub_term = sub_digit | sub_letter;

small_term = number | letter;

sub_expr = '_' small_term | sub_term {sub_sym sub_term};

super_term = super_digit;

id_sub = base_id [sub_expr];

base_term =
    sym | id_sub [parens_exprs | "‚ãØ" id_sub]
  | '‚ä§' | '‚ä•' | parens_exprs
  | '{' var of_type '|' proposition '}';

term = base_term [super_term];

terms = term+;

(* expressions *)

binary_op = '¬∑' | '+' | '-' | '‚àà' | '‚àâ' | '|' | '‚à§' | '‚àß' | '‚à®' | '‚Üí' | '‚Üî';

compare_op = '=' | '<' | '‚â§' | '>' | '‚â•' | '~' | '‚äÜ';

eq_op = compare_op | '‚â†' | '‚âÆ' | '‚âØ';

expr = terms |
    expr binary_op expr |
    expr eq_op expr |
    expr ':' typ |
    '-' expr |
    '¬¨' expr |
    '‚àÄ' decl_ids_type '.' expr;

exprs = expr { 'and' expr };

predicate_target =
    'as' atomic | 'of' atomic ['and' atomic] | 'from' atomic 'to' atomic;

predicate =
    ['not'] adjective |
    ('a' | 'an' | 'the') word [word] predicate_target;

atomic =
    expr ['is true' | 'always holds' | ('is' | 'must' ['also'] 'be') predicate];

(* reasons *)

id_eq_term = id '=' term;

theorem_ref = '[' name [':' id_eq_term {',' id_eq_term}] ']';

reference = theorem_ref | 'our assumption that' atomic |
    'part (' number ')' ['of this theorem'];

reason =
    ['contradiction with'] reference |
    [['the'] ('inductive' | 'induction')] ('assumption' | 'hypothesis') |
    'definition' | 'the definition of' term |
    'transitivity of =';

by_reason = ['again'] 'by' reason {'and' reason};

(* so / have *)

so = 'also' | 'but' ['then'] | 'consequently' | 'hence' | 'however' |
     'so' | 'that is' | 'then' | 'therefore' | 'thus' | 'which implies' ['that'] |
     'whence' | 'which means that';
    
have = 'clearly' |
    'it' ['then'] 'follows' ['from' reference | by_reason] 'that' |
    'it is' ('clear' | 'obvious') 'that' | 'it must be that' | 'observe that' |
    'on the other hand' [','] | 'similarly' [','] |
    'the only alternative is' | 'this means that' | 'this shows that' | 'trivially' |
    'we conclude that' | 'we deduce that' | 'we have' ['shown that'] |
    'we know that' | 'we must have' | 'we see that';

(* small propositions *)

if_then_prop = 'if' small_prop [','] 'then' small_prop;

with_exprs = 'with' exprs;

for_all_ids = 'For all' decl_ids_types;

for_all_prop = for_all_ids [with_exprs] [','] small_prop;

there_exists = 'There' ('is' | 'are' | 'exists' | ['must'] 'exist');

exists_prop =
    there_exists ['some' | 'an operation' | 'no'] decl_ids_types [with_exprs]
    'such that' small_prop;

precisely_prop = ('Exactly' | 'Precisely') 'one of' small_prop 'holds';

prop_op = 'and' | 'or' | 'if' | 'implies' ['that'] | 'if and only if' | 'iff' |
          ', and' | ', or';

small_prop =
    atomic | if_then_prop | for_all_prop | exists_prop | precisely_prop |
    small_prop prop_op small_prop |
    small_prop 'is' predicate |
    small_prop 'for' ('all' | 'some') decl_ids_type [with_exprs];

(* propositions *)

either_or_prop = 'either' small_prop;

cannot_prop = 'It cannot be that' small_prop;

proposition =
    either_or_prop | cannot_prop |
    small_prop;

(* top propositions, which may include steps *)

operation = ('a' | 'an') ['binary' | 'unary'] ('operation' | 'relation');

let_decl = 'Consider any' decl_ids_types |
    'Let' (decl_ids_types ['be' operation] | id 'be a type');

let_step = let_decl [with_exprs];

let_val_step = 'let' id_opt_type '=' expr;

define_step = 'define' atomic for_all_ids;

let_def_step = let_val_step | define_step;

suppose = ['Also'] ('assume' | 'suppose') ['further'] ['that'] proposition
            {[','] 'and that' proposition};

assume_step = suppose;

let_or_assume = let_step | let_def_step | assume_step;

top_prop = {let_or_assume '.'} ['Then'] proposition;

(* proposition lists *)

sub_index = (letter | number) '.';

label = '[' name ']';

top_sentence = top_prop '.' [label];

stmt_name = '(' name ')';

proposition_item = sub_index top_sentence;

prop_items = proposition_item+;

top_prop_or_items = prop_items | top_sentence;

propositions = [for_all_ids ','] top_prop_or_items;

(* axioms *)

type_decl = 'a type' id ['(' 'the' word [word] ')'];

const_decl = ('a constant' | 'an element' | 'a function' | operation) id_or_sym of_type;

axiom_decl = type_decl | const_decl;

axiom_exists = 
    there_exists axiom_decl {('and' | 'with') axiom_decl}
    ('such that' propositions | '.');

axiom_group = 'Axiom' [stmt_name] '.' (axiom_exists | propositions);

(* definitions *)

def_prop = ['we write'] small_prop '.';

definition =
    'Definition.' {let_decl '.'} [for_all_ids ','] {['Let'] def_prop}+;

(* proofs *)

because_prop = ['because' | 'since'] proposition;

contradiction = 
     ('a contradiction' ['to' reference] | 'contradicting' reference)
     [because_prop];

which_is_contradiction =
    ',' (['which is'] ['again' | 'also' | 'similarly']) contradiction;

prop_reason = proposition [by_reason];

proof_eq_props = prop_reason {eq_op prop_reason}+;

proof_prop =
    ([by_reason [',']] [have] proof_eq_props) [which_is_contradiction];

proof_if_prop = 'if' small_prop [','] 'then' proof_prop {',' so proof_prop};

and_or_so = 'and' [so] | so;

will_show = ('We' ('must' | 'need to' | 'will'))
            ['now'] ('deduce' | 'prove' | 'show') [by_reason] 'that';

to_show = 'To show that' small_prop ',';

assert_step =
    [have] proof_if_prop |
    because_prop [','] proof_prop |
    [to_show] will_show proposition |
    'The result follows' by_reason |
    [so] ('This is' | 'We have') contradiction |
    [and_or_so] proof_prop;

assert_steps = assert_step {',' and_or_so proof_prop};

now = 'Conversely' | 'Finally' | 'Next' | 'Now' | 'Second';

any_case = 'in' ('all cases' | 'any case' | 'both cases' | 'either case') ;

let_or_assumes = let_or_assume {', and' let_or_assume};

clause_intro = 'First' | now | any_case;

proof_clause = [clause_intro [',']] (let_or_assumes | assert_steps);

proof_sentence = proof_clause {';' proof_clause} '.' [label];

proof_steps = proof_sentence+;

proof_item = sub_index proof_steps;

proofs = 'Proof.' (proof_item+ | proof_steps);

(* theorems *)

theorem_group = ('Corollary' | 'Lemma' | 'Theorem') [stmt_name] '.' {let_step '.'}
    top_prop_or_items [proofs];

(* module *)

module_name = {letter | digit | '_' }+;

using = 'using' module_name {',' module_name} ';' ;

module = [using] {axiom_group | definition | theorem_group};
