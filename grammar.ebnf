(* types *)

type_op = '⨯' | '→'

typ = id | (typ) | typ type_op typ

of_type = ':' | '∈'

id_type = id of_type typ

id_opt_type = id [of_type typ]

ids_type = id {',' id}+ of_type typ

(* terms *)

term =
    sym | id '(' expr {, expr} ')' | var | '(' expr ')'
  | '{' var of_type typ '|' proposition '}'

terms = term+

(* expressions *)

op = '·' | '+' | '∈' | '=' | '≠' | '<' | '≤' | '>' | '≥' | '≮'

expr = terms | expr op expr

atomic = expr ['is true' | 'always holds']

(* small propositions *)

prop_op = 'and' | 'or' | 'implies' | 'if and only if' | ', and' | ', or'

small_prop = atomic | small_prop prop_op small_prop | small_prop 'for all' id_type

(* propositions *)

if_then_prop = 'if' small_prop 'then' small_prop

either_or_prop = 'either' small_prop

for_all_ids = 'For all' ids_type ','

for_all_prop = for_all_ids proposition

there_exists = 'There' ('is' | 'are' | 'exists' | 'exist')

exists_prop = there_exists ('some' | 'no') ids_type 'such that' proposition

precisely_prop = 'Precisely one of' small_prop 'holds'

cannot_prop = 'It cannot be that' proposition

proposition =
    for_all_prop | exists_prop | if_then_prop |
    either_or_prop | precisely_prop | cannot_prop |
    small_prop

(* top propositions *)

let_prop = 'Let' id_type '.' top_prop

suppose = 'Suppose that' proposition {', and that' proposition} '.'
    'Then' proposition

top_prop = let_prop | suppose | proposition

(* proposition lists *)

label = (letter | number) '.'

top_sentence = top_prop '.'

proposition_item = label top_sentence ['(' word ')']

prop_items = proposition_item+

top_prop_or_items = prop_items | top_sentence

propositions = [for_all_ids] top_prop_or_items

(* axioms *)

operation = 'a' ['binary' | 'unary'] 'operation'

axiom_decl = 'a type' id |
    (('an element' | 'a function' | operation) id_or_sym of_type typ)

axiom_group = 'Axiom' int '.'
    there_exists axiom_decl {('and' | 'with') axiom_decl}
    ('such that' propositions | '.')

(* definitions *)

eq_definition = 'Let' sym ':' typ '=' term '.'

relation_definition = ['we write'] id sym id 'iff' proposition '.'

definition = 'Definition.'
    ({eq_definition}+ | for_all_ids {relation_definition})

(* proofs *)

theorem_num = number {'.' number}

theorem_ref =
    ('lemma' | 'theorem') theorem_num |
    'part (' number ')' ['of this theorem']

reason = 'by' ( theorem_ref | 'hypothesis')

so = 'hence' | 'so' | 'then' | 'therefore' | 'which implies' ['that']
    
have = 'clearly' | 'it' ['then'] 'follows' [reason] 'that' |
    'the only alternative is' |
    'we conclude that' | 'we deduce that' | 'we have' | 'we know that' |
    'we must have' | 'we see that'

so_or_have = so | [reason] have

contra = ',' ['which is'] ['again' | 'also' | 'similarly'] 'a contradiction' ['to' theorem_ref]

proof_intro_prop = reason [','] [have] proposition [contra]

proof_prop = proof_intro_prop | proposition [reason] [contra]

proof_if_prop = 'if' small_prop [','] 'then' proof_prop {',' so proof_prop}

assert_step =
    proof_if_prop |
    proof_intro_prop |
    ['And'] so_or_have proof_prop |
    'Since' proof_prop ',' have proof_prop |
    ('We will show that' | 'We start by showing that') proposition

assert_steps = assert_step {',' ('and' so_or_have | so) proof_prop}

now = 'Conversely' | 'First' | 'Finally' | 'Next' | 'Now' |
    'Putting the cases together'

let_step = 'let' ids_type ['with' small_prop]

let_val_step = 'let' id_opt_type '=' term

assume_step = 'Suppose that' proposition

let_or_assume = let_val_step | let_step | assume_step

let_or_assumes = let_or_assume {", and" let_or_assume}

proof_clause = [now [,]] (let_or_assumes | assert_steps)

proof_sentence = proof_clause {';' proof_clause} '.'

proof_steps = proof_sentence+

proof_item = label proof_steps

proofs = 'Proof.' (proof_item+ | proof_steps)

(* theorems *)

theorem_group = ('Lemma' | 'Theorem') int '.' 'Let' ids_type '.'
    top_prop_or_items [proofs]

(* program *)

program = {axiom_group | definition | theorem_group}
