(* lexical *)

digit = '0' .. '9';

number = {digit}+;

letter = 'a' .. 'z';

var = letter;

id = 'gcd' | var | 'ùîπ' | '‚Ñï' | '‚Ñ§' | 'œÄ' | '‚àè';

sym = digit |
    '+' | '-' | '<' | '>' | '|' |
    '¬∑' | '‚â§' | '‚â•' | '‚âÆ' | '‚âØ' | '‚àí';

id_or_sym = id | sym;

word = letter {letter};

adjective = word;

(* types *)

type_op = '‚®Ø' | '‚Üí';

typ = id | typ type_op typ;

of_type = ':' | '‚àà';

id_type = id of_type typ;

id_opt_type = id [of_type typ];

ids_type = id {',' id}+ of_type typ;

ids_types = ids_type {'and' ids_type};

(* reasons *)

theorem_num = number {'.' number} ['(' letter ')'];

reference =
    ('axiom' | 'corollary' | 'lemma' | 'theorem') theorem_num |
    'part (' number ')' ['of this theorem'] |
    'the definition of' var;

reason = (('by' | 'using') reference) | 'by' ['the inductive'] 'hypothesis';

(* terms *)

term =
    sym | id '(' expr {',' expr} ')' | id | '‚ä§' | '‚ä•' | '(' expr ')'
  | '{' var of_type typ '|' proposition '}';

terms = term+;

(* expressions *)

binary_op = '¬∑' | '+' | '-' | '‚àà' | '‚àâ' | '|' | '‚àß' | '‚à®' | '‚Üí' | '‚Üî';

base_expr = terms |
    base_expr binary_op base_expr |
    base_expr ':' typ |
    '-' base_expr |
    '¬¨' base_expr;

eq_op = '=' | '‚â†' | '<' | '‚â§' | '>' | '‚â•' | '‚âÆ';

expr = base_expr { eq_op base_expr [reason] };

predicate_target = 'of' atomic ['and' atomic] | 'from' atomic 'to' atomic;

predicate =
    ['not'] adjective |
    ('a' | 'an') word [word] predicate_target;

atomic = expr ['is true' | 'always holds' | 'is' predicate];

(* small propositions *)

if_then_prop = 'if' small_prop 'then' small_prop;

for_all_ids = 'For all' ids_types ',';

for_all_prop = for_all_ids small_prop;

there_exists = 'There' ('is' | 'are' | 'exists' | ['must'] 'exist');

exists_prop =
    there_exists ['some' | 'no'] ids_types ['with' small_prop]
    'such that' small_prop;

prop_op = 'and' | 'or' | 'implies' | 'if and only if' | 'iff' | ', and' | ', or';

small_prop =
    atomic | if_then_prop | for_all_prop | exists_prop |
    small_prop prop_op small_prop |
    small_prop 'is' predicate |
    small_prop 'for all' id_type;

(* propositions *)

either_or_prop = 'either' small_prop;

precisely_prop = ('Exactly' | 'Precisely') 'one of' small_prop 'holds';

cannot_prop = 'It cannot be that' proposition;

proposition =
    either_or_prop | precisely_prop | cannot_prop |
    small_prop;

(* top propositions *)

let_prop = 'Let' id_type '.' top_prop;

suppose = 'Suppose' ['further'] 'that' proposition {[','] 'and that' proposition};

suppose_then = suppose '.' 'Then' proposition;

top_prop = let_prop | suppose_then | proposition;

(* proposition lists *)

label = (letter | number) '.';

top_sentence = top_prop '.';

proposition_item = label top_sentence ['(' word ')'];

prop_items = proposition_item+;

top_prop_or_items = prop_items | top_sentence;

propositions = [for_all_ids] top_prop_or_items;

(* axioms *)

operation = ('a' | 'an') ['binary' | 'unary'] ('operation' | 'relation');

axiom_decl = 'a type' id |
    (('a constant' | 'an element' | 'a function' | operation) id_or_sym of_type typ);

axiom_exists = 
    there_exists axiom_decl {('and' | 'with') axiom_decl}
    ('such that' propositions | '.');

axiom_group = 'Axiom' number '.' (axiom_exists | propositions);

(* definitions *)

eq_definition = 'Let' sym ':' typ '=' term '.';

def_prop = ['we write'] proposition '.';

definition = 'Definition.' ({eq_definition}+ | {def_prop});

(* proofs *)

so = 'also' | 'but' | 'consequently' | 'hence' | 'however' | 'so' | 'then' | 'therefore' |
    'which implies' ['that'] | 'which means that';
    
have = 'clearly' |
    'it' ['then'] 'follows' ['from' reference | reason] 'that' |
    'it is clear that' | 'it must be that' | 'similarly' [','] |
    'the only alternative is' | 'this shows that' |
    'we conclude that' | 'we deduce that' | 'we have' | 'we know that' |
    'we must have' | 'we see that';

contra = ',' ['which is'] ['again' | 'also' | 'similarly'] 'a contradiction' ['to' reference];

proof_prop = (reason [','] [have] proposition |
              [have] proposition [reason]) [contra];

proof_if_prop = 'if' small_prop [','] 'then' proof_prop {',' so proof_prop};

and_or_so = 'and' [so] | so;

will_show =
    'We need to show that' |
    'We start by showing that' |
    'We will' ('show' | 'deduce') 'that';

to_show = 'To show that' small_prop ',';

assert_step =
    [have] proof_if_prop |
    ['Because' | 'Since'] proof_prop ',' proof_prop |
    [to_show] will_show proposition |
    'The result follows' reason |
    'This is a contradiction' ['to' reference] |
    [and_or_so] proof_prop;

assert_steps = assert_step {',' and_or_so proof_prop};

now = 'Conversely' | 'Finally' | 'Next' | 'Now' | 'Second';

any_case = 'In any case' | 'In either case' | 'Putting the cases together';

let_step = 'let' ids_type ['with' small_prop];

let_val_step = 'let' id_opt_type '=' term;

assume_step = suppose;

let_or_assume = let_val_step | let_step | assume_step;

let_or_assumes = let_or_assume {", and" let_or_assume};

clause_intro = 'First' | now | any_case;

proof_clause = [clause_intro [',']] (let_or_assumes | assert_steps);

proof_sentence = proof_clause {';' proof_clause} '.';

proof_steps = proof_sentence+;

proof_item = label proof_steps;

proofs = 'Proof.' (proof_item+ | proof_steps);

(* theorems *)

theorem_group = ('Corollary' | 'Lemma' | 'Theorem') number '.' ['Let' ids_types '.']
    top_prop_or_items [proofs];

(* program *)

program = {axiom_group | definition | theorem_group};
