(* lexical *)

digit = '0' .. '9';

number = {digit}+;

letter = 'a' .. 'z';

var = letter;

id = 'gcd' | var | 'ùîπ' | '‚Ñï' | '‚Ñ§' | 'œÄ' | '‚àè';

sym = digit |
    '+' | '-' | '<' | '>' | '|' |
    '¬∑' | '‚â§' | '‚â•' | '‚âÆ' | '‚âØ' | '‚àí';

id_or_sym = id | sym;

word = letter {letter};

adjective = word;

name = {letter | digit | '_'}+;

sub_digit = '‚ÇÄ' .. '‚Çâ';

sub_var = '‚Çê' .. '‚Çì';

sub_sym = '‚Çä' | '‚Çã';

(* types *)

type_op = '‚®Ø' | '‚Üí';

typ = id | typ type_op typ | '(' typ ')';

of_type = ':' | '‚àà';

id_type = id of_type typ;

id_opt_type = id [of_type typ];

ids = id {',' id}+;

ids_type = ids of_type typ;

ids_types = ids_type {'and' ids_type};

(* reasons *)

theorem_ref = ':' name;

reference = theorem_ref | 'part (' number ')' ['of this theorem'];

reason = (('by' | 'using') reference) |
          'by' ['the' ('inductive' | 'induction')] ('assumption' | 'hypothesis') |
          'by definition';

(* terms *)

parens_exprs = '(' expr {',' expr} ')';

sub_term = sub_digit | sub_var;

sub_expr = sub_term {sub_sym sub_term};

term =
    sym | id [parens_exprs | sub_expr ["‚ãØ" id sub_expr]]
  | '‚ä§' | '‚ä•' | parens_exprs
  | '{' var of_type typ '|' proposition '}';

terms = term+;

(* expressions *)

binary_op = '¬∑' | '+' | '-' | '‚àà' | '‚àâ' | '|' | '‚à§' | '‚àß' | '‚à®' | '‚Üí' | '‚Üî';

base_expr = terms |
    base_expr binary_op base_expr |
    base_expr ':' typ |
    '-' base_expr |
    '¬¨' base_expr;

eq_op = '=' | '‚â†' | '<' | '‚â§' | '>' | '‚â•' | '‚âÆ';

expr = base_expr { eq_op base_expr [reason] };

exprs = expr { 'and' expr };

predicate_target =
    'as' atomic | 'of' atomic ['and' atomic] | 'from' atomic 'to' atomic;

predicate =
    ['not'] adjective |
    ('a' | 'an' | 'the') word [word] predicate_target;

atomic = expr ['is true' | 'always holds' | 'is' predicate];

(* small propositions *)

if_then_prop = 'if' small_prop [','] 'then' small_prop;

with_exprs = 'with' exprs;

for_all_ids = 'For all' ids_types;

for_all_prop = for_all_ids [with_exprs] [','] small_prop;

there_exists = 'There' ('is' | 'are' | 'exists' | ['must'] 'exist');

exists_prop =
    there_exists ['some' | 'no'] ids_types [with_exprs]
    'such that' small_prop;

prop_op = 'and' | 'or' | 'implies' ['that'] | 'if and only if' | 'iff' |
          ', and' | ', or';

small_prop =
    atomic | if_then_prop | for_all_prop | exists_prop |
    small_prop prop_op small_prop |
    small_prop 'is' predicate |
    small_prop 'for' ('all' | 'some') id_type [with_exprs];

(* propositions *)

either_or_prop = 'either' small_prop;

precisely_prop = ('Exactly' | 'Precisely') 'one of' small_prop 'holds';

cannot_prop = 'It cannot be that' proposition;

proposition =
    either_or_prop | precisely_prop | cannot_prop |
    small_prop;

(* top propositions *)

let_prop = 'Let' id_type '.' top_prop;

suppose = ['Also'] ['assume' | 'suppose'] ['further'] 'that' proposition
            {[','] 'and that' proposition};

suppose_then = suppose '.' 'Then' proposition;

top_prop = let_prop | suppose_then | proposition;

(* proposition lists *)

label = (letter | number) '.';

top_sentence = top_prop '.' ['[' name ']'];

stmt_name = '(' name ')';

proposition_item = label top_sentence;

prop_items = proposition_item+;

top_prop_or_items = prop_items | top_sentence;

propositions = [for_all_ids ','] top_prop_or_items;

(* axioms *)

operation = ('a' | 'an') ['binary' | 'unary'] ('operation' | 'relation');

type_decl = 'a type' id ['(' 'the' word [word] ')'];

const_decl = ('a constant' | 'an element' | 'a function' | operation) id_or_sym of_type typ;

axiom_decl = type_decl | const_decl;

axiom_exists = 
    there_exists axiom_decl {('and' | 'with') axiom_decl}
    ('such that' propositions | '.');

axiom_group = 'Axiom' [stmt_name] '.' (axiom_exists | propositions);

(* definitions *)

eq_definition = 'Let' sym ':' typ '=' term '.';

def_prop = ['we write'] proposition '.';

definition = 'Definition.' ({eq_definition}+ | for_all_ids ',' {def_prop});

(* proofs *)

so = 'also' | 'but' ['then'] | 'consequently' | 'hence' | 'however' | 'so' | 'then' | 'therefore' |
    'which implies' ['that'] | 'which means that';
    
have = 'clearly' |
    'it' ['then'] 'follows' ['from' reference | reason] 'that' |
    'it is clear that' | 'it must be that' |
    'on the other hand' [','] | 'similarly' [','] |
    'the only alternative is' | 'this shows that' | 'trivially' |
    'we conclude that' | 'we deduce that' | 'we have' ['shown that'] |
    'we know that' | 'we must have' | 'we see that';

contra = ',' ['which is'] ['again' | 'also' | 'similarly'] 'a contradiction' ['to' reference];

proof_prop = (reason [','] [have] proposition |
              [have] proposition [reason]) [contra];

proof_if_prop = 'if' small_prop [','] 'then' proof_prop {',' so proof_prop};

and_or_so = 'and' [so] | so;

will_show =
    'We need to show that' |
    'We start by showing that' |
    'We will' ('show' | 'deduce') 'that';

to_show = 'To show that' small_prop ',';

assert_step =
    [have] proof_if_prop |
    ['Because' | 'Since'] proof_prop [','] proof_prop |
    [to_show] will_show proposition |
    'The result follows' reason |
    'This is a contradiction' ['to' reference] |
    [and_or_so] proof_prop;

assert_steps = assert_step {',' and_or_so proof_prop};

now = 'Conversely' | 'Finally' | 'Next' | 'Now' | 'Second';

any_case = 'In any case' | 'In either case' | 'Putting the cases together';

let_step = 'let' ids_type [with_exprs];

let_val_step = 'let' id_opt_type '=' expr;

assume_step = suppose;

let_or_assume = let_val_step | let_step | assume_step;

let_or_assumes = let_or_assume {', and' let_or_assume};

clause_intro = 'First' | now | any_case;

proof_clause = [clause_intro [',']] (let_or_assumes | assert_steps);

proof_sentence = proof_clause {';' proof_clause} '.';

proof_steps = proof_sentence+;

proof_item = label proof_steps;

proofs = 'Proof.' (proof_item+ | proof_steps);

(* theorems *)

theorem_group = ('Corollary' | 'Lemma' | 'Theorem') [stmt_name] '.' ['Let' ids_types '.']
    top_prop_or_items [proofs];

(* program *)

program = {axiom_group | definition | theorem_group};
