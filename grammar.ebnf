(* types *)

of_type = ':' | '∈'

id_type = id of_type typ

id_opt_type = id [of_type typ]

ids_type = id {',' id}+ of_type typ

(* terms *)

term =
    sym | id '(' expr ')' | var | '(' expr ')'
  | '{' var of_type typ '|' proposition '}'

terms = term+

(* expressions *)

op = '·' | '+' | '∈' | '=' | '≠' | '<' | '≤' | '>' | '≥' | '≮'

expr = terms | expr op expr

atomic = expr ['is true']

(* small propositions *)

prop_op = 'and' | 'or' | 'implies' | 'if and only if' | ', and' | ', or'

small_prop = atomic | small_prop prop_op small_prop | small_prop 'for all' id_type

(* propositions *)

if_then_prop = 'if' small_prop 'then' small_prop

either_or_prop = 'either' small_prop

for_all_ids = 'For all' ids_type ','

for_all_prop = for_all_ids proposition

exists_prop = 'There is' ('some' | 'none') id_type 'such that' proposition

precisely_prop = 'Precisely one of' small_prop 'holds'

cannot_prop = 'It cannot be that' proposition

proposition =
    for_all_prop | exists_prop | if_then_prop |
    either_or_prop | precisely_prop | cannot_prop |
    small_prop

(* top propositions *)

let_prop = 'Let' id_type '.' top_prop

suppose = 'Suppose that' proposition {', and that' proposition} '.'
    'Then' proposition

top_prop = let_prop | suppose | proposition

(* proposition lists *)

label = (letter | number) '.'

proposition_item = label top_prop '.' ['(' word ')']

prop_items = proposition_item+

top_prop_or_items = prop_items | top_prop '.'

propositions = [for_all_ids] top_prop_or_items

(* axioms *)

axiom_decl = 'a type' id |
    (('an element' | 'a function' | 'a binary operation') id_or_sym of_type typ)

axiom_group = 'Axiom' int '.'
    ('There exists' | 'There is') axiom_decl {('and' | 'with') axiom_decl}
    ('such that' propositions | '.')

(* definitions *)

eq_definition = 'Let' sym ':' typ '=' term '.'

relation_definition = ['we write'] id sym id 'iff' proposition '.'

definition = 'Definition.' (eq_definition | for_all_ids {relation_definition})

(* proofs *)

so = 'hence' | 'so' | 'then' | 'therefore'
    
have = 'it follows that' |
    'we deduce that' | 'we have' | 'we must have' | 'we see that'

so_or_have = so | have

reason = 'by'
    ('lemma' number |
     'part (' number ')' ['of this theorem'] |
     'hypothesis')

contra = ',' 'which is a contradiction'

proof_intro_prop =
    'if' small_prop [','] 'then' proof_prop |
    reason [','] [have] proposition [contra]

proof_prop = proof_intro_prop | proposition [reason] [contra]

assert_step =
    proof_intro_prop | ['and'] so_or_have proof_prop | 'Since' proof_prop ',' have proof_prop

assert_steps = assert_step {',' ('and' so_or_have | so) proof_prop}

_let = ['First' | 'Now'] 'let'

let_step = _let ids_type ['with' small_prop]

let_val_step = _let id_opt_type '=' term

assume_step = 'Suppose that' proposition

let_or_assume = let_val_step | let_step | assume_step

let_or_assumes = let_or_assume {", and" let_or_assume}

proof_sentence = (let_or_assumes | assert_steps) '.'

proof_steps = proof_sentence+

proof_item = label proof_steps

proofs = 'Proof.' (proof_item+ | proof_steps)

(* theorems *)

theorem_group = ('Lemma' | 'Theorem') int '.' 'Let' ids_type '.'
    top_prop_or_items [proofs]

(* program *)

program = {axiom_group | definition | theorem_group}
